DROP POLICY "Users can view attendees for their events" ON "public"."attendee";

ALTER TABLE "public"."attendee"
    DROP CONSTRAINT "attendee_account_id_fkey";

DROP FUNCTION IF EXISTS "public"."get_accounts_for_user" ();

DROP VIEW IF EXISTS "public"."event_stats";

ALTER TABLE "public"."attendee"
    DROP CONSTRAINT "attendee_pkey";

DROP INDEX IF EXISTS "public"."attendee_pkey";

CREATE TABLE "public"."contact" (
    "id" bigint GENERATED BY DEFAULT AS IDENTITY NOT NULL,
    "created_at" timestamp with time zone DEFAULT now(),
    "account_id" bigint NOT NULL,
    "hash" text NOT NULL,
    "name" text,
    "email" text,
    "organization_id" bigint
);

ALTER TABLE "public"."contact" ENABLE ROW LEVEL SECURITY;

ALTER TABLE "public"."attendee"
    DROP COLUMN "account_id";

ALTER TABLE "public"."attendee"
    ADD COLUMN "contact_id" bigint NOT NULL;

CREATE UNIQUE INDEX contact_account_id_hash_key ON public.contact USING btree (account_id, hash);

CREATE UNIQUE INDEX contact_pkey ON public.contact USING btree (id);

CREATE UNIQUE INDEX attendee_pkey ON public.attendee USING btree (event_id, contact_id);

ALTER TABLE "public"."contact"
    ADD CONSTRAINT "contact_pkey" PRIMARY KEY USING INDEX "contact_pkey";

ALTER TABLE "public"."attendee"
    ADD CONSTRAINT "attendee_pkey" PRIMARY KEY USING INDEX "attendee_pkey";

ALTER TABLE "public"."attendee"
    ADD CONSTRAINT "attendee_contact_id_fkey" FOREIGN KEY (contact_id) REFERENCES contact (id) ON DELETE CASCADE NOT valid;

ALTER TABLE "public"."attendee" validate CONSTRAINT "attendee_contact_id_fkey";

ALTER TABLE "public"."contact"
    ADD CONSTRAINT "contact_account_id_fkey" FOREIGN KEY (account_id) REFERENCES account (id) ON DELETE CASCADE NOT valid;

ALTER TABLE "public"."contact" validate CONSTRAINT "contact_account_id_fkey";

ALTER TABLE "public"."contact"
    ADD CONSTRAINT "contact_organization_id_fkey" FOREIGN KEY (organization_id) REFERENCES organization (id) ON DELETE SET NULL NOT valid;

ALTER TABLE "public"."contact" validate CONSTRAINT "contact_organization_id_fkey";

SET check_function_bodies = OFF;

CREATE OR REPLACE FUNCTION public.link_contact_to_organization ()
    RETURNS TRIGGER
    LANGUAGE plpgsql
    SECURITY DEFINER
    SET search_path TO 'public'
    AS $function$
BEGIN
    IF NEW.email IS NOT NULL THEN
        NEW.organization_id = (
            SELECT
                public.get_or_create_organization_id (NEW.email));
    END IF;
    RETURN NEW;
END
$function$;

CREATE OR REPLACE FUNCTION public.calculate_day (_account_id bigint, _day date)
    RETURNS void
    LANGUAGE plpgsql
    AS $function$
DECLARE
    events jsonb[] := '{}';
    e jsonb;
    lengths jsonb = '{}'::jsonb;
    cur integer := NULL;
    nxt integer;
    priority integer := 0;
    matches bigint[];
    m bigint;
    gap integer := 0;
    _focus_minutes integer := 0;
    _focus_blocks integer := 0;
    _slack_minutes integer := 0;
    _slack_blocks integer := 0;
BEGIN
    SELECT
        ARRAY (
            SELECT
                jsonb_build_object('id', id, 'start', FLOOR(EXTRACT(epoch FROM LOWER(at)) / 60), 'end', FLOOR(EXTRACT(epoch FROM UPPER(at)) / 60), 'priority', response_priority (response))
            FROM
                event
            WHERE
                account_id = _account_id
                AND day = _day
                AND (response IS NULL
                    OR response != 'declined')
                AND type IS NOT NULL
                AND type != 'focus'
                AND is_cancelled = FALSE
            ORDER BY
                LOWER(at) ASC,
                response_priority (response) DESC) INTO events;
    IF FOUND THEN
        cur := (events[1] ->> 'start')::integer;
    END IF;
    FOREACH e IN ARRAY events LOOP
        lengths[(e ->> 'id')::text] = 0;
    END LOOP;
    LOOP
        nxt := 2147483647;
        -- max
        priority := 0;
        matches := '{}';
        FOREACH e IN ARRAY events LOOP
            -- The first event that starts later
            IF (e ->> 'start')::integer > cur THEN
                -- If we reached the next start without matching, there's a gap
                IF nxt = 2147483647 THEN
                    gap := LEAST ((e ->> 'start')::integer, (events[1] ->> 'start')::integer + 8 * 60) - cur;
                    IF gap > 30 THEN
                        _focus_minutes := _focus_minutes + gap;
                        _focus_blocks := _focus_blocks + 1;
                    ELSE
                        _slack_minutes := _slack_minutes + gap;
                        _slack_blocks := _slack_blocks + 1;
                    END IF;
                END IF;
                nxt := LEAST (nxt, (e ->> 'start')::integer);
                EXIT;
            END IF;
            -- Events that are already done, or lower priority
            CONTINUE
            WHEN (e ->> 'end')::integer <= cur
                OR (e ->> 'priority')::integer < priority;
            nxt := LEAST (nxt, (e ->> 'end')::integer);
            IF (e ->> 'priority')::integer > priority THEN
                priority := e ->> 'priority';
                matches := '{}';
            END IF;
            matches := matches || (e ->> 'id')::bigint;
        END LOOP;
        FOREACH m IN ARRAY matches LOOP
            lengths[m::text] = (lengths ->> (m::text))::real + (nxt - cur) / ARRAY_LENGTH(matches, 1);
        END LOOP;
        EXIT
        WHEN nxt = 2147483647;
        cur := nxt;
    END LOOP;
    UPDATE
        event AS e
    SET
        attended_length = (lengths ->> (e.id::text))::int
    WHERE
        e.id IN (
            SELECT
                key::int
            FROM
                jsonb_each_text(lengths));
    -- There's usally a final gap, with whatever time remains in the eight-hour day
    gap := 8 * 60;
    IF cur IS NOT NULL THEN
        gap := gap - (cur - (events[1] ->> 'start')::integer);
    END IF;
    -- Only add focus and slack on weekdays
    IF EXTRACT(ISODOW FROM _day) < 6 THEN
        IF gap > 30 THEN
            _focus_minutes := _focus_minutes + gap;
            _focus_blocks := _focus_blocks + 1;
        ELSIF gap > 0 THEN
            _slack_minutes := _slack_minutes + gap;
            _slack_blocks := _slack_blocks + 1;
        END IF;
    END IF;
    INSERT INTO day (account_id, day, focus_minutes, focus_blocks, slack_minutes, slack_blocks)
        VALUES (_account_id, _day, _focus_minutes, _focus_blocks, _slack_minutes, _slack_blocks)
    ON CONFLICT (account_id, day)
        DO UPDATE SET
            focus_minutes = EXCLUDED.focus_minutes, focus_blocks = EXCLUDED.focus_blocks, slack_minutes = EXCLUDED.slack_minutes, slack_blocks = EXCLUDED.slack_blocks;
END
$function$;

CREATE OR REPLACE VIEW "public"."event_stats" AS
SELECT
    e.id,
    e.created_at,
    e.account_id,
    e.cal_id,
    e.series,
    e.at,
    (floor(((EXTRACT(epoch FROM upper(e.at)) - EXTRACT(epoch FROM lower(e.at))) / (60)::numeric)))::integer AS length,
    e.title,
    e.type,
    e.attended_length,
    e.is_cancelled,
    e.is_online,
    e.is_onsite,
    e.is_offsite,
    e.response,
    string_agg((a.contact_id)::text, ','::text ORDER BY a.contact_id) AS invitees,
    count(*) AS invitee_count,
    count(*) FILTER (WHERE (a.response = 'accepted'::attendance)) AS attendee_count
FROM (event e
    JOIN attendee a ON (e.id = a.event_id))
GROUP BY
    e.id;

CREATE OR REPLACE FUNCTION public.link_series (account_id bigint)
    RETURNS void
    LANGUAGE plpgsql
    AS $function$
BEGIN
    UPDATE
        event
    SET
        series = subquery.series
    FROM (
        SELECT
            ARRAY_AGG(id),
            MAX(series) AS series
        FROM
            event_stats
        WHERE
            event_stats.account_id = $1
        GROUP BY
            title,
            invitees
        HAVING
            COUNT(*) > 1) AS subquery
WHERE
    event.id = ANY (subquery.array_agg);
END;
$function$;

CREATE POLICY "Users can view attendees for their events" ON "public"."attendee" AS permissive
    FOR SELECT TO authenticated
        USING ((auth.uid () IN (
            SELECT
                account.user_id
            FROM (account
            JOIN event ON (account.id = event.account_id))
        WHERE (event.id = attendee.event_id))));

CREATE TRIGGER on_contact_created
    BEFORE INSERT ON public.contact
    FOR EACH ROW
    EXECUTE FUNCTION link_contact_to_organization ();

